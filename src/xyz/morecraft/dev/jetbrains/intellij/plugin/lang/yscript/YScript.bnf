{
  parserClass="xyz.morecraft.dev.jetbrains.intellij.plugin.lang.yscript.parser.YScriptParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="YScript"
  psiImplClassSuffix="Impl"
  psiPackage="xyz.morecraft.dev.jetbrains.intellij.plugin.lang.yscript.psi"
  psiImplPackage="xyz.morecraft.dev.jetbrains.intellij.plugin.lang.yscript.psi.impl"

  elementTypeHolderClass="xyz.morecraft.dev.jetbrains.intellij.plugin.lang.yscript.psi.YScriptTypes"
  elementTypeClass="xyz.morecraft.dev.jetbrains.intellij.plugin.lang.yscript.psi.YScriptElementType"
  tokenTypeClass="xyz.morecraft.dev.jetbrains.intellij.plugin.lang.yscript.psi.YScriptTokenType"

  psiImplUtilClass="xyz.morecraft.dev.jetbrains.intellij.plugin.lang.yscript.psi.impl.YScriptPsiImplUtil"
}

YScriptFile ::= ((structuralItem X_SEMICOLON) | COMMENT | EOL)*

structuralItem ::= (import | program | define)

import ::= KEY_IMPORT package

//noinspection BnfResolve
program ::= KEY_PROGRAM package X_OPEN_BRACKET vars? X_CLOSE_BRACKET (KEY_RETURNS type)? (block | externalProgram) {
    methods=[getPackageName];
    stubClass="xyz.morecraft.dev.jetbrains.intellij.plugin.lang.yscript.index.YScriptProgramStub";
    extends="xyz.morecraft.dev.jetbrains.intellij.plugin.lang.yscript.psi.impl.YScriptStubbedElementImpl<?>";
    elementTypeFactory="xyz.morecraft.dev.jetbrains.intellij.plugin.lang.yscript.psi.stub.YScriptElementTypeFactory.stubFactory"
}

externalProgram ::= KEY_EXTERNAL V_STRING X_OPEN_BRACKET arguments? X_CLOSE_BRACKET

define ::= KEY_DEFINE type KEY_AS (KEY_EXTENSION KEY_OF type)? blockDefine

package ::= IDENTIFIER (X_DOUBLE_COLON IDENTIFIER)*

vars ::= var (X_COMMA var)*

var ::= KEY_VAR varDef

varDef ::= IDENTIFIER KEY_AS type

type ::= (KEY_ARRAY KEY_OF)? IDENTIFIER (X_COLON V_STRING)?

statement ::= (var | return | if | with | while | create | sort | index | delete | try | throw | for | assign | merge | anyCall)

if ::= KEY_IF expression KEY_THEN body (KEY_ELSE body)?

with ::= (withLoop | withObj)

withLoop ::= KEY_WITH IDENTIFIER KEY_AS expression KEY_DO body

withObj ::= KEY_WITH propertySimple KEY_DO body

while ::= KEY_WHILE expression KEY_DO body

create ::= KEY_CREATE propertySimple block?

sort ::= KEY_SORT propertySimple KEY_USING package;

index ::= KEY_INDEX propertySimple KEY_USING propertySimple;

delete ::= KEY_DELETE propertySimple

try ::= KEY_TRY block (KEY_CATCH X_OPEN_BRACKET var X_CLOSE_BRACKET block)+

throw ::= KEY_THROW (new | expression)

for ::= KEY_FOR IDENTIFIER X_ASSIGN V_NUMBER KEY_TO expression KEY_DO body

return ::= KEY_RETURN expression?;

assign ::= propertySimple X_ASSIGN (expression | new)

merge ::= propertySimple KEY_MERGE propertySimple

new ::= KEY_NEW type block?

expression ::= (expressionTerm operator expression) | expressionTerm

expressionTerm ::= (expressionFactor operator expressionTerm) | expressionFactor

expressionFactor ::= (expressionDotted | expressionSimple)

expressionDotted ::= (expressionBraced | cast | anyCall) (X_DOT expressionFactor)?

expressionBraced ::= X_OPEN_BRACKET expression X_CLOSE_BRACKET

expressionSimple ::= KEY_NEGATION? (fIsInstance | fIsType | cast | anyCall | value | boolean | propertySimple)

operator ::= (KEY_AND | KEY_OR | OP_LT | OP_GT | OP_LTE | OP_GTE | OP_PLUS | OP_MINUS | OP_MUL | OP_DIVIDE | OP_MODULO | OP_EQIALS | OP_NEQUALS)

boolean ::= (KEY_TRUE | KEY_FALSE)

cast ::= X_OPEN_BRACKET expressionFactor KEY_AS type X_CLOSE_BRACKET

private anyCall ::= fSizeOf | fIsSet | fCopyOf | fIsNull | fType | call

call ::= package X_OPEN_BRACKET arguments? X_CLOSE_BRACKET

arguments ::= expression (X_COMMA expression)*

propertySimple ::= propertyBase (X_DOT propertyBase)*

propertyBase ::= IDENTIFIER (bracketSingleExpression|bracketDoubleExpression)?

bracketSingleExpression ::= X_OPEN_SQUARE_BRACKET expression X_CLOSE_SQUARE_BRACKET

bracketDoubleExpression ::= X_OPEN_SQUARE_BRACKET X_OPEN_SQUARE_BRACKET expression X_CLOSE_SQUARE_BRACKET X_CLOSE_SQUARE_BRACKET

value ::= (KEY_NULL | V_STRING | V_NUMBER)

fIsInstance ::= propertySimple F_KEY_IS_INSTANCE X_OPEN_BRACKET type X_CLOSE_BRACKET
// TODO 'expression' instead of 'propertySimple'

fIsType ::= propertySimple F_KEY_IS_TYPE X_OPEN_BRACKET type X_CLOSE_BRACKET
// TODO 'expression' instead of 'propertySimple'

fSizeOf ::= F_KEY_SIZE_OF X_OPEN_BRACKET propertySimple X_CLOSE_BRACKET

fIsSet ::= F_KEY_IS_SET X_OPEN_BRACKET propertySimple X_CLOSE_BRACKET

fCopyOf ::= F_KEY_COPY_OF X_OPEN_BRACKET propertySimple X_CLOSE_BRACKET

fIsNull ::= F_KEY_IS_NULL X_OPEN_BRACKET propertySimple X_CLOSE_BRACKET

fType ::= F_KEY_TYPE X_OPEN_BRACKET propertySimple X_CLOSE_BRACKET

body ::= (block | statement)

block ::= KEY_BEGIN (statement X_SEMICOLON)* KEY_END

blockDefine ::= KEY_BEGIN (varDef X_SEMICOLON)* KEY_END